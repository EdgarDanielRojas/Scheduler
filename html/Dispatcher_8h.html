<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Process Scheduler: Dispatcher.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Process Scheduler
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dispatcher.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="Dispatcher_8h__dep__incl.png" border="0" usemap="#Dispatcher_8hdep" alt=""/></div>
<map name="Dispatcher_8hdep" id="Dispatcher_8hdep">
<area shape="rect" id="node2" href="scheduler_8c.html" title="scheduler.c" alt="" coords="9,80,98,107"/>
</map>
</div>
</div>
<p><a href="Dispatcher_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a964b2403608c07df2515952097f05abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8h.html#a964b2403608c07df2515952097f05abc">FirstCome</a> (GList *process_list)</td></tr>
<tr class="memdesc:a964b2403608c07df2515952097f05abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the First Come First Serve algorithm to a process list.  <a href="#a964b2403608c07df2515952097f05abc">More...</a><br /></td></tr>
<tr class="separator:a964b2403608c07df2515952097f05abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599e59d14d7ee7842b19c81839aeb238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8h.html#a599e59d14d7ee7842b19c81839aeb238">NonPreemptive</a> (GList *process_list, int type)</td></tr>
<tr class="memdesc:a599e59d14d7ee7842b19c81839aeb238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a NonPreemptive algorithm to a process list.  <a href="#a599e59d14d7ee7842b19c81839aeb238">More...</a><br /></td></tr>
<tr class="separator:a599e59d14d7ee7842b19c81839aeb238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd155be10d9300d3ab6c03db06086aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8h.html#afd155be10d9300d3ab6c03db06086aa8">Preemptive</a> (GList *process_list, int type)</td></tr>
<tr class="memdesc:afd155be10d9300d3ab6c03db06086aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a Preemptive algorithm to a process list.  <a href="#afd155be10d9300d3ab6c03db06086aa8">More...</a><br /></td></tr>
<tr class="separator:afd155be10d9300d3ab6c03db06086aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69540eab87c7aec0b7471e42a4b6e00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8h.html#af69540eab87c7aec0b7471e42a4b6e00">RoundRobin</a> (GList *process_list, int quantum)</td></tr>
<tr class="memdesc:af69540eab87c7aec0b7471e42a4b6e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Round Robin algorithm to a process list.  <a href="#af69540eab87c7aec0b7471e42a4b6e00">More...</a><br /></td></tr>
<tr class="separator:af69540eab87c7aec0b7471e42a4b6e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a964b2403608c07df2515952097f05abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964b2403608c07df2515952097f05abc">&#9670;&nbsp;</a></span>FirstCome()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FirstCome </td>
          <td>(</td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>process_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the First Come First Serve algorithm to a process list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_list</td><td>Head of the process list containing all the processes ordered by arrival time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output Calls <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>.</dd></dl>
<p>The function creates a copy of the process list arriving using <a class="el" href="Process_8c.html#af87ca937324b42cc09757825d6df7f67" title="Copies a process list. ">CopyList()</a> so the copy list can be manipulated without fear of changing the original values of the list. Once the copy is made, the algorithm calculates the time the process runs by assigning it the current time and making the time equal to the time plus the process' cpu burst. We can do this since the algorithm is sequential. </p>

</div>
</div>
<a id="a599e59d14d7ee7842b19c81839aeb238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599e59d14d7ee7842b19c81839aeb238">&#9670;&nbsp;</a></span>NonPreemptive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NonPreemptive </td>
          <td>(</td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>process_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a NonPreemptive algorithm to a process list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_list</td><td>Head of the process list containing all the processes ordered by arrival time. </td></tr>
    <tr><td class="paramname">type</td><td>enum value of sort_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output Calls <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>.</dd></dl>
<p>The function creates a copy of the process list arriving using <a class="el" href="Process_8c.html#af87ca937324b42cc09757825d6df7f67" title="Copies a process list. ">CopyList()</a> so the copy list can be manipulated without fear of changing the original values of the list. Once the copy is made, the algorithm applied is basically the same for the two type of NonPreemptive algorithms (SJF and Priority). First we create a new list called runningList which will house the current processes in queue. Next the algorithm enters a loop where it will exit once the runningList is NULL. Inside the algorithm there are basically two conditions we have to check, if a process arrives at our current time and if our current running process has finished. If a process arrive, the queue is sorted based on the NonPreemptive algorithm chosen. If a process finishes running, then we remove it from the runningList and run the next process. We increment the time with each iteration and once it finishes we print the averag wait time using <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>. </p>

</div>
</div>
<a id="afd155be10d9300d3ab6c03db06086aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd155be10d9300d3ab6c03db06086aa8">&#9670;&nbsp;</a></span>Preemptive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Preemptive </td>
          <td>(</td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>process_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a Preemptive algorithm to a process list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_list</td><td>Head of the process list containing all the processes ordered by arrival time. </td></tr>
    <tr><td class="paramname">type</td><td>enum value of sort_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output Calls <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>.</dd></dl>
<p>The function creates a copy of the process list arriving using <a class="el" href="Process_8c.html#af87ca937324b42cc09757825d6df7f67" title="Copies a process list. ">CopyList()</a> so the copy list can be manipulated without fear of changing the original values of the list. Once the copy is made, the algorithm applied is basically the same for the two type of Preemptive algorithms (SJF and Priority). First we create a new list called runningList which will house the current processes in queue. Next the algorithm enters a loop where it will exit once the runningList is NULL. Inside the algorithm there are basically two conditions we have to check, if a process arrives at our current time and if our current running process has finished. The first to be checked is if the process has finished execution, if it has, we remove it from our runningList and execute the next process in queue. If a process arrives at our current time we add it to the runningList and sort said list. In the case that the process running is no longer the process at the head of the queue, we switch out the process with the process at the head of the queue. We increment the time with each iteration and once it finishes we print the average wait time using <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>. </p>

</div>
</div>
<a id="af69540eab87c7aec0b7471e42a4b6e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69540eab87c7aec0b7471e42a4b6e00">&#9670;&nbsp;</a></span>RoundRobin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoundRobin </td>
          <td>(</td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>process_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quantum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Round Robin algorithm to a process list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_list</td><td>Head of the process list containing all the processes ordered by arrival time. </td></tr>
    <tr><td class="paramname">quantum</td><td>The size of the quantum used in the algorithm</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output Calls <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>.</dd></dl>
<p>The function creates a copy of the process list arriving using <a class="el" href="Process_8c.html#af87ca937324b42cc09757825d6df7f67" title="Copies a process list. ">CopyList()</a> so the copy list can be manipulated without fear of changing the original values of the list. First we create a new list called runningList which will house the current processes in queue. Next the algorithm enters a loop where it will exit once the runningList is NULL. Inside the algorithm there are basically three conditions we must check. The first one is if the current running process has finished running. If that is the case the process is removed from the queue and the Next process in queue is executed. The second one is if the current running process has run for the determined quantum. If it has then it is put to the end of the queue so it may execute later. Lastly we search the process list to find if a process arrives at the current time. If we do find a process then we put it at the end of the queue so it may execute later. All this is repeated until all processes run and the runningList is left at NULL. We increment the time with each iteration and once it finishes we print the average wait time using <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
