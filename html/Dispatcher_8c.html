<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Process Scheduler: Dispatcher.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Process Scheduler
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dispatcher.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;glib.h&gt;</code><br />
<code>#include &quot;<a class="el" href="Process_8h_source.html">Process.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Dispatcher.c:</div>
<div class="dyncontent">
<div class="center"><img src="Dispatcher_8c__incl.png" border="0" usemap="#Dispatcher_8c" alt=""/></div>
<map name="Dispatcher_8c" id="Dispatcher_8c">
<area shape="rect" id="node4" href="Process_8h.html" title="Process.h" alt="" coords="169,80,250,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af9cdd8647ec1f7c1d199317dc6e51f9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c">PrintAverageWaitTime</a> (GList *process_list, char *tipo)</td></tr>
<tr class="memdesc:af9cdd8647ec1f7c1d199317dc6e51f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the average wait time of a list.  <a href="#af9cdd8647ec1f7c1d199317dc6e51f9c">More...</a><br /></td></tr>
<tr class="separator:af9cdd8647ec1f7c1d199317dc6e51f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa62608071998b9d8cd032597d7a66e"><td class="memItemLeft" align="right" valign="top">GList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8c.html#a6fa62608071998b9d8cd032597d7a66e">addToList</a> (GList *running_list, GList *result)</td></tr>
<tr class="memdesc:a6fa62608071998b9d8cd032597d7a66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds processes to a running list.  <a href="#a6fa62608071998b9d8cd032597d7a66e">More...</a><br /></td></tr>
<tr class="separator:a6fa62608071998b9d8cd032597d7a66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964b2403608c07df2515952097f05abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8c.html#a964b2403608c07df2515952097f05abc">FirstCome</a> (GList *process_list)</td></tr>
<tr class="memdesc:a964b2403608c07df2515952097f05abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the First Come First Serve algorithm to a process list.  <a href="#a964b2403608c07df2515952097f05abc">More...</a><br /></td></tr>
<tr class="separator:a964b2403608c07df2515952097f05abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55123651fc59e434e7c7dc2ebcc2873"><td class="memItemLeft" align="right" valign="top">gint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8c.html#ac55123651fc59e434e7c7dc2ebcc2873">funcArrival</a> (gpointer a, int *b)</td></tr>
<tr class="memdesc:ac55123651fc59e434e7c7dc2ebcc2873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to find a process that arrives at a given time.  <a href="#ac55123651fc59e434e7c7dc2ebcc2873">More...</a><br /></td></tr>
<tr class="separator:ac55123651fc59e434e7c7dc2ebcc2873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599e59d14d7ee7842b19c81839aeb238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8c.html#a599e59d14d7ee7842b19c81839aeb238">NonPreemptive</a> (GList *process_list, int type)</td></tr>
<tr class="memdesc:a599e59d14d7ee7842b19c81839aeb238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a NonPreemptive algorithm to a process list.  <a href="#a599e59d14d7ee7842b19c81839aeb238">More...</a><br /></td></tr>
<tr class="separator:a599e59d14d7ee7842b19c81839aeb238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd155be10d9300d3ab6c03db06086aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8c.html#afd155be10d9300d3ab6c03db06086aa8">Preemptive</a> (GList *process_list, int type)</td></tr>
<tr class="memdesc:afd155be10d9300d3ab6c03db06086aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a Preemptive algorithm to a process list.  <a href="#afd155be10d9300d3ab6c03db06086aa8">More...</a><br /></td></tr>
<tr class="separator:afd155be10d9300d3ab6c03db06086aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69540eab87c7aec0b7471e42a4b6e00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dispatcher_8c.html#af69540eab87c7aec0b7471e42a4b6e00">RoundRobin</a> (GList *process_list, int quantum)</td></tr>
<tr class="memdesc:af69540eab87c7aec0b7471e42a4b6e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Round Robin algorithm to a process list.  <a href="#af69540eab87c7aec0b7471e42a4b6e00">More...</a><br /></td></tr>
<tr class="separator:af69540eab87c7aec0b7471e42a4b6e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6fa62608071998b9d8cd032597d7a66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa62608071998b9d8cd032597d7a66e">&#9670;&nbsp;</a></span>addToList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GList* addToList </td>
          <td>(</td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>running_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds processes to a running list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">running_list</td><td>Head of the running list to which we shall add processes. </td></tr>
    <tr><td class="paramname">result</td><td>Head of our results taken from our search function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GList* Returns the new head of the running list once elements are added.</dd></dl>
<p>The way the function is used is that it adds elements based on arrival time. When it is called it is know that the result in it´s data field holds a process that has arrived at the time it is called. Once it's data element is added to the running list we use it's arrival time to compare with the rest of the elements in the result list. This is because more than one element can arrive at the same time. In the case that an element does not have a same arrival time we stop searching the list. In the case that an element does have the same arrival time, it is added to the list. </p>

</div>
</div>
<a id="a964b2403608c07df2515952097f05abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964b2403608c07df2515952097f05abc">&#9670;&nbsp;</a></span>FirstCome()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FirstCome </td>
          <td>(</td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>process_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the First Come First Serve algorithm to a process list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_list</td><td>Head of the process list containing all the processes ordered by arrival time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output Calls <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>.</dd></dl>
<p>The function creates a copy of the process list arriving using <a class="el" href="Process_8c.html#af87ca937324b42cc09757825d6df7f67" title="Copies a process list. ">CopyList()</a> so the copy list can be manipulated without fear of changing the original values of the list. Once the copy is made, the algorithm calculates the time the process runs by assigning it the current time and making the time equal to the time plus the process' cpu burst. We can do this since the algorithm is sequential. </p>

</div>
</div>
<a id="ac55123651fc59e434e7c7dc2ebcc2873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55123651fc59e434e7c7dc2ebcc2873">&#9670;&nbsp;</a></span>funcArrival()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gint funcArrival </td>
          <td>(</td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to find a process that arrives at a given time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>GPointer with the direction to a process. </td></tr>
    <tr><td class="paramname">b</td><td>Pointer to an integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer used to determine if the search has a match.</dd></dl>
<p>The function works alongside g_list_find_custom to find a process running at a given time. The pointer received is converted to a Process and it's process_arrival time is substracted the time we pass as a parameter. If 0, then we found a process arriving at that time. </p>

</div>
</div>
<a id="a599e59d14d7ee7842b19c81839aeb238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599e59d14d7ee7842b19c81839aeb238">&#9670;&nbsp;</a></span>NonPreemptive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NonPreemptive </td>
          <td>(</td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>process_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a NonPreemptive algorithm to a process list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_list</td><td>Head of the process list containing all the processes ordered by arrival time. </td></tr>
    <tr><td class="paramname">type</td><td>enum value of sort_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output Calls <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>.</dd></dl>
<p>The function creates a copy of the process list arriving using <a class="el" href="Process_8c.html#af87ca937324b42cc09757825d6df7f67" title="Copies a process list. ">CopyList()</a> so the copy list can be manipulated without fear of changing the original values of the list. Once the copy is made, the algorithm applied is basically the same for the two type of NonPreemptive algorithms (SJF and Priority). First we create a new list called runningList which will house the current processes in queue. Next the algorithm enters a loop where it will exit once the runningList is NULL. Inside the algorithm there are basically two conditions we have to check, if a process arrives at our current time and if our current running process has finished. If a process arrive, the queue is sorted based on the NonPreemptive algorithm chosen. If a process finishes running, then we remove it from the runningList and run the next process. We increment the time with each iteration and once it finishes we print the averag wait time using <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>. </p>

</div>
</div>
<a id="afd155be10d9300d3ab6c03db06086aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd155be10d9300d3ab6c03db06086aa8">&#9670;&nbsp;</a></span>Preemptive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Preemptive </td>
          <td>(</td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>process_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a Preemptive algorithm to a process list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_list</td><td>Head of the process list containing all the processes ordered by arrival time. </td></tr>
    <tr><td class="paramname">type</td><td>enum value of sort_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output Calls <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>.</dd></dl>
<p>The function creates a copy of the process list arriving using <a class="el" href="Process_8c.html#af87ca937324b42cc09757825d6df7f67" title="Copies a process list. ">CopyList()</a> so the copy list can be manipulated without fear of changing the original values of the list. Once the copy is made, the algorithm applied is basically the same for the two type of Preemptive algorithms (SJF and Priority). First we create a new list called runningList which will house the current processes in queue. Next the algorithm enters a loop where it will exit once the runningList is NULL. Inside the algorithm there are basically two conditions we have to check, if a process arrives at our current time and if our current running process has finished. The first to be checked is if the process has finished execution, if it has, we remove it from our runningList and execute the next process in queue. If a process arrives at our current time we add it to the runningList and sort said list. In the case that the process running is no longer the process at the head of the queue, we switch out the process with the process at the head of the queue. We increment the time with each iteration and once it finishes we print the average wait time using <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>. </p>

</div>
</div>
<a id="af9cdd8647ec1f7c1d199317dc6e51f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cdd8647ec1f7c1d199317dc6e51f9c">&#9670;&nbsp;</a></span>PrintAverageWaitTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrintAverageWaitTime </td>
          <td>(</td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>process_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tipo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the average wait time of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_list</td><td>Head of the process list that will have the average wait time of it´s elements calculated </td></tr>
    <tr><td class="paramname">tipo</td><td>Text that contains the type of algorithm that was used on the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output Prints out the type of algorithm used and the average wait time for that algorithm</dd></dl>
<p>The function takes a pointer to the head of the list and using it loops through the whole list, calculating the wait time for each data element (<a class="el" href="structprocess__p.html">process_p</a>) . Once it calculates the wait time of the element it adds it to the total wait time of the proceses and divides it by the number of processes which was taken using a counter. g_list_length could also be used but it does the same thing in it´s function definition. </p>

</div>
</div>
<a id="af69540eab87c7aec0b7471e42a4b6e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69540eab87c7aec0b7471e42a4b6e00">&#9670;&nbsp;</a></span>RoundRobin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoundRobin </td>
          <td>(</td>
          <td class="paramtype">GList *&#160;</td>
          <td class="paramname"><em>process_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quantum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Round Robin algorithm to a process list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_list</td><td>Head of the process list containing all the processes ordered by arrival time. </td></tr>
    <tr><td class="paramname">quantum</td><td>The size of the quantum used in the algorithm</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output Calls <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>.</dd></dl>
<p>The function creates a copy of the process list arriving using <a class="el" href="Process_8c.html#af87ca937324b42cc09757825d6df7f67" title="Copies a process list. ">CopyList()</a> so the copy list can be manipulated without fear of changing the original values of the list. First we create a new list called runningList which will house the current processes in queue. Next the algorithm enters a loop where it will exit once the runningList is NULL. Inside the algorithm there are basically three conditions we must check. The first one is if the current running process has finished running. If that is the case the process is removed from the queue and the Next process in queue is executed. The second one is if the current running process has run for the determined quantum. If it has then it is put to the end of the queue so it may execute later. Lastly we search the process list to find if a process arrives at the current time. If we do find a process then we put it at the end of the queue so it may execute later. All this is repeated until all processes run and the runningList is left at NULL. We increment the time with each iteration and once it finishes we print the average wait time using <a class="el" href="Dispatcher_8c.html#af9cdd8647ec1f7c1d199317dc6e51f9c" title="Prints the average wait time of a list. ">PrintAverageWaitTime()</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
